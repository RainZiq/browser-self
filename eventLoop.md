# 消息队列与事件循环
浏览器的每个渲染进程都有一个主线程，用来下载资源、解析dom、样式、布局、执行js、监听事件，管理子线程，为了更好的调度这么多的任务，提供了一个消息队列和事件循环的机制

# 消息队列
存放任务的队列，以及和主线程接收其它线程的任务的地方，主线程的任务都是从消息队列里面读取执行的

# 事件循环
主线程在空闲的时候取出消息队列的任务进行执行，不断循环的过程

# 宏任务
消息队列里面的任务

# 微任务
js层面的任务 promise.then() ... 

# 执行顺序
宏任务---->微任务
v8：编译执行js,需要知道怎么执行，变量如何存在，执行的顺序，所以v8提供了一个堆空间、执行栈来执行js

首先浏览器是不认识js代码的，所以v8会先编译成ast然后解释执行它，在编译代码的时候会生成一个执行栈，一段js代码，v8会把他封装成一个匿名函数，所以同时也就生成了一个全局的执行上下文，并且push到执行栈。

开始执行：
执行栈依次执行同步代码，遇到异步任务，会交给各自的线程取执行，例如XMLHttpRequest会交给网络进程去执行，然后网络进程获取到结果封装成一个任务放到消息队列，等到主线程空闲的时候再去读取执行。setTimeout会放到延迟队列里面，让延迟队列满足条件之后把他封装成一个任务加到消息队列里面。这些直接放到消息队列里面的任务都被称为宏任务。

由于宏任务时间粒度比较大，执行的时间间隔不能精确控制，所以v8引入了微任务的概念，v8在创建全局上下文的时候，会在内部创建一个微任务队列，也就是说每个对于每个宏任务，v8都维持了一个微任务队列。

例如，我们需要使用MutationObserve监听一个dom节点变化之后做一些操作，如果采用监听的方式，让dom发生变化，渲染引擎同步的调用这些接口，这样会导致当前执行任务被拉长，影响了执行效率，
但是如果做成异步的处理，把他封装成任务放到消息队列，这样可能会因为消息队列里面有很多的任务，影响了时效性，所以微任务就出现了

当一个宏任务中的同步代码都被执行完成之后，他不会立即去执行下一个宏任务，会去清空当前的微任务队列，这样既不会影响宏任务的同步代码继续执行，也保证了实时性

这是对js脚本的分析，消息队列也可以放解析dom任务，分析一波
```js
<!DOCTYPE html>
<html>
    <body>
        <div id='demo'>
            <ol>
                <li>test</li>
            </ol>
        </div>
    </body>
    <script type="text/javascript">
        function timerCallback2(){
          console.log(2)
        }
        function timerCallback(){
            console.log(1)
            setTimeout(timerCallback2,0)
        }
        new Promise(()=>{

        }).then(()=>{
          console.log('微任务')
        })
        setTimeout(timerCallback,0)
    </script>
</html>
```
独立团要搞点动作，说咱们下一个任务是什么啊，一营长说解析dom，上次他娘的把我们卡爆了，害的被旅长骂了一顿，李云龙说他娘的就搞他，这次老子有消息队列还有事件循环，干他娘的。
独立团要解析dom，李云龙先派兵生成dom树，然后发现遇到了js这个硬骨头，他就说v8你他娘的执行栈呢拉出来给我把他干了，v8说好啊，准备工作到位了，上弹，突然发现一营长的侧城门也想要支援啊，李云龙说她娘的都想打炮，算了等我这一炮我就去支援，刚刚准备发射，突然侦擦员说这个解析dom有个小据点啊，我们要不要拔了他，李云龙说，你他娘的不知道窝窝头哪个大吗，咱们先把这个解决了，小据点排好队，下次老子去收拾他。
好的发射，他娘的城门解决了，还有侧门也去开一炮。好 这个解析dom咱们是完成了，不是说还有一个小据点啊，等我们把这里打扫完战场就去干他一炮


首先，渲染线程开始工作，从消息队列里面取出来解析dom的任务（宏任务），主线程通过htplParse一系列的解析生成dom树，渲染dom，突然发现了一段js代码，这个时候主线程就说v8引擎他娘的该你工作了，把你的执行栈，全局执行上下文准备好，我把主线程让给你，你搞快点。
v8引擎预解析代码发现里面有定时器啊，还有微任务，然后它默默准备了一个延迟队列，一个微任务队列，
开始执行代码，把微任务加入解析dom这个宏任务的微任务队列，把定时器加到延迟队列，说等你好了你就自己去消息队列当宏任务，就不用他娘的受气了。这个时候js同步快执行完了，然后v8就去检查微任务队列了，发现里面还有一个微任务啊，赶紧把他执行了，免得被骂。好的我把js执行完成了，主线程还给你。
这个时候解析dom说 你是真他娘的墨迹，行了我收个尾就好了，这个时候主线程的解析dom任务就结束了，主线程空了就想搞点事情，又去看看消息队列里面有没有任务让我执行玩一玩，好的延迟队列以及把定时器封装成一个新的任务了，故事继续

异步操作解决同步操作的性能问题
微任务解决了实时性的问题